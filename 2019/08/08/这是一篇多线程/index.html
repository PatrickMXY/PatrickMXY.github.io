<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Patrick yangmx_patrick@foxmail.com"><title>这是一篇多线程 · Patrick</title><meta name="description" content="这是一篇介绍多线程的博文，主要是GCD的理解和使用，记录下自己对多线程的理解吧。鉴于各大平台都在唱衰Object-C ，所以文中代码都是Swift。
移动端开发过程中对多线程的运用可能不会像服务器那样频繁，或是说很多需要多线程处理的时候都有成熟的第三方库帮我们坐好了类似AFNetworking，会把"><meta name="keywords" content="Object-C,Swift,Flutter"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Patrick</a></h3><div class="description"><p>记录生活，记录bug</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">时间戳</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>这是一篇多线程</a></h3></div><div class="post-content"><p>这是一篇介绍多线程的博文，主要是GCD的理解和使用，记录下自己对多线程的理解吧。鉴于各大平台都在唱衰<code>Object-C</code> ，所以文中代码都是<code>Swift</code>。</p>
<p>移动端开发过程中对多线程的运用可能不会像服务器那样频繁，或是说很多需要多线程处理的时候都有成熟的第三方库帮我们坐好了类似<code>AFNetworking</code>，会把网络请求这种需要开辟线程的好事操作都处理好，但毕竟是别人的不是。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>先说下对多线程的理解，我们可以简单的将它比作食堂打饭的场景，原本就一个主队列的窗口，排队打饭的人就是我们待执行的任务，先来先打，至于是否需要新增窗口、新增几个窗口需要有管理员来决定（对，你现在就是管理员了）。</p>
<p>回到编程需要我们先理解几个概念</p>
<p><strong>任务</strong>：我们每一行有效的代码都可视作任务，它有两种执行方式，同步和异步。</p>
<p>  <strong>.同步执行</strong><code>queue.sync{}</code> 在当前线程顺序执行.</p>
<p>  <strong>.异步执行</strong><code>queue.async{}</code>有开辟新线程的能力（至于开几个、开不开，得看你执行队列）。</p>
<p><strong>队列</strong>：是一种特殊的线性表，主要负责存放任务，采用FIFO（先进先出）的原则，看做排队打饭的队伍即可。很巧他也有两种类型，串行，并行。</p>
<p>  <strong>.串行</strong>（<code>Serial queue</code>）  一个线程里按顺序执行，我们的主线程就是个特殊的串行队列</p>
<p>  <strong>.并发</strong>（<code>Concurrent queue</code>） 可以同时处理多个任务，既然是同时处理，当然也是可以开辟新线程的</p>
<p>这么就引申出了好几种组合</p>
<table>
<thead>
<tr>
<th>区别</th>
<th>并发队列</th>
<th>串行队列</th>
<th align="left">主队列</th>
</tr>
</thead>
<tbody><tr>
<td>同步(sync)</td>
<td><del>没有开启新线程，串行执行任务</del></td>
<td><del>没有开启新线程，串行执行任务</del></td>
<td align="left"><del>死锁卡住不执行</del></td>
</tr>
<tr>
<td>异步(async)</td>
<td>开新线程，并发执行任务</td>
<td>开启一个新线程，串行执行</td>
<td align="left"><del>不开启新线程，串行执行</del></td>
</tr>
</tbody></table>
<p>在介绍几种用法之前我们把基本不会用的组合标出来了，简单说下原因。</p>
<p>  <strong>.主队列里同步、异步执行</strong>：同步执行卡死，显然不可取，异步执行，开不了新线程，还是串行执行，这根做无用功有啥区别？</p>
<p>  <strong>.并发队列里同步执行</strong>：同上，串行执行，与同主队列执行没有区别，又是无用功好像。</p>
<p>  <strong>.串行队列里同步执行</strong>：放在主队列里直接执行不是更好吗？</p>
<p>当然仅代表个人观点，最主要的是为了把这几种组合缩减成我们常用的</p>
<h4 id="GCD的使用"><a href="#GCD的使用" class="headerlink" title="GCD的使用"></a>GCD的使用</h4><p>使用的流程大抵就是有一个队列，然后通过同步或者异步的方式去执行任务</p>
<h5 id="串行队列-异步执行"><a href="#串行队列-异步执行" class="headerlink" title="串行队列+异步执行"></a>串行队列+异步执行</h5><p>先看下实际中的简单使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        创建一个串行队列</span></span><br><span class="line"><span class="keyword">let</span> myFormatter = <span class="type">DateFormatter</span>.<span class="keyword">init</span>()</span><br><span class="line">myFormatter.dateFormat = <span class="string">"hh:mm:ss"</span></span><br><span class="line"><span class="keyword">let</span> serialQueue = <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">"SerialQueue"</span>)</span><br><span class="line"><span class="comment">//        异步执行耗时操作</span></span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))当前线程\(Thread.current)"</span>)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">serialQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))当前线程\(Thread.current)"</span>)</span><br><span class="line">    sleep(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>:<span class="number">57</span>:<span class="number">29</span>当前线程&lt;<span class="type">NSThread</span>: <span class="number">0x60000093b280</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">04</span>:<span class="number">57</span>:<span class="number">34</span>当前线程&lt;<span class="type">NSThread</span>: <span class="number">0x60000093b280</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>输出信息可以发现两次间隔5秒，并且在同一个新线程里执行，那是因为我们当前的队列是串行的，他只会顺序执行我们里面的任务。说下之前实际开发中的使用场景，会把所有的通知扔到一个串行队列里，顺序推送这种。</p>
<h5 id="并行队列-异步执行"><a href="#并行队列-异步执行" class="headerlink" title="并行队列+异步执行"></a>并行队列+异步执行</h5><p>这大概是我们用的最多的方式了，经常我们多个耗时操作，却又不想卡住UI线程时比便会用到，先看下用法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        qos:yuserInteractive 需要用户交互的，优先级最高，和主线程一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        .userInitiated 即将需要，用户期望优先级，优先级高比较高</span></span><br><span class="line"><span class="comment">//        .default 默认优先级</span></span><br><span class="line"><span class="comment">//        .utility 需要执行一段时间后，再通知用户，优先级低</span></span><br><span class="line"><span class="comment">//        *.background 后台执行的，优先级比较低</span></span><br><span class="line"><span class="comment">//        *.unspecified 不指定优先级，最低</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     attributes 表示队列类型，默认为串行队列，设置为.concurrent表示并行队列。iOS 10.0之后 attributes 新增.initiallyInactive属性表示当前队列是不活跃的，它需要调用DispatchQueue的activate方法来执行任务。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        autoreleaseFrequency 表示自动释放频率，设置自动释放机制。</span></span><br><span class="line"><span class="comment">//        .inherit 表示不确定，之前默认的行为也是现在的默认值</span></span><br><span class="line"><span class="comment">//        .workItem 表示为每个执行的项目创建和排除自动释放池, 项目完成时清理临时对象</span></span><br><span class="line"><span class="comment">//        .never 表示GCD不为您管理自动释放池</span></span><br><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">"ConcurrentQueue"</span>, qos: <span class="type">DispatchQoS</span>.<span class="keyword">default</span>, attributes: <span class="type">DispatchQueue</span>.<span class="type">Attributes</span>.concurrent, autoreleaseFrequency:.workItem, target: <span class="literal">nil</span>)</span><br><span class="line"><span class="comment">//顺带验证下在并发队列里同步执行任务会不会开启线程</span></span><br><span class="line">concurrentQueue.sync &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"同步执行\(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">同步执行&lt;<span class="type">NSThread</span>: <span class="number">0x6000035ee880</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">05</span>:<span class="number">36</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000035844c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">05</span>:<span class="number">36</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x600003589140</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">05</span>:<span class="number">36</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x600003584500</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">05</span>:<span class="number">46</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x600003584500</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">05</span>:<span class="number">46</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x600003589140</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">05</span>:<span class="number">46</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000035844c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>输出信息看的到利用同步的方式执行并发队列的任务时不会开辟新线程的，他其实绕了一圈还在主线程里执行的</p>
<p>在之我们异步的方式执行并发队列的任务的时候会看到当耗时操作过多时，系统会根据需求开辟多条线程去执行任务，保证任务完成的效率，类似服务器需要大批量数据写入，或者是网络请求操作时，放在子线程操作，操作结束告诉主线程就行了。这里就引申除了一个新的问题，线程通讯</p>
<h5 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h5><p>因为苹果规定在UI相关的操作都必须要放在主线程里执行，所以当我们在子线程里操作UI相关的时候会crash掉</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Main</span> <span class="type">Thread</span> <span class="type">Checker</span>: <span class="type">UI</span> <span class="type">API</span> called on a background thread: -[<span class="type">UIView</span> <span class="keyword">init</span>]</span><br><span class="line"><span class="type">PID</span>: <span class="number">2244</span>, <span class="type">TID</span>: <span class="number">216898</span>, <span class="type">Thread</span> name: (<span class="keyword">none</span>), <span class="type">Queue</span> name: <span class="type">ConcurrentQueue</span>, <span class="type">QoS</span>: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<p>看下错误信息即便英语在查的关键字拼凑也看得出UI API 不支持在其他线程访问的，那怎么告诉主线程呢，这就涉及到了线程通讯，一句话就可以实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"回到主线程"</span>)</span><br><span class="line">   <span class="comment">//这里可以操作UI</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里又牵涉到一个问题，刚才多线程执行耗时操作的时候倘若我们需要在所有并发任务执行结束后回到主线程怎么破？毕竟每个线程执行都是随机的，在任意一个子线程里回到主线程做相关操作貌似都不合理，这里又引申出了一个新的东西Group，可以把它看做是线程管理的工具。</p>
<h4 id="DispatchGroup"><a href="#DispatchGroup" class="headerlink" title="DispatchGroup"></a>DispatchGroup</h4><p>使用场景，当多个耗时操作在同一个线程内顺序执行时，我们又刚好需要得到多个线程执行结果时，便会用到<code>DispatchGroup</code>。在解释它的作用之前我们同样用一段代码来看一下它的使用</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>.<span class="keyword">init</span>()</span><br><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">"ConcurrentQueue"</span>, qos: <span class="type">DispatchQoS</span>.<span class="keyword">default</span>, attributes: <span class="type">DispatchQueue</span>.<span class="type">Attributes</span>.concurrent, autoreleaseFrequency:.workItem, target: <span class="literal">nil</span>)</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    group.enter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    group.enter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;</span><br><span class="line">concurrentQueue.async &#123;</span><br><span class="line">    group.enter()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">    group.leave()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">group.notify(queue: concurrentQueue) &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))回到主线程\(Thread.current)"</span>)</span><br><span class="line">        <span class="keyword">self</span>.view .addSubview(<span class="type">UIView</span>.<span class="keyword">init</span>())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">01</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x600002274980</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">01</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x60000225a000</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">01</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000022744c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">12</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000022744c0</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">12</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x60000225a000</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">12</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x600002274980</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">02</span>:<span class="number">39</span>:<span class="number">12</span>回到主线程&lt;<span class="type">NSThread</span>: <span class="number">0x60000221e940</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>group.enter()</code>后面的任务是需要你加入到group里的任务，它跟<code>group.leave()</code>是会对应出现的，代表这个任务结束并通知group，仅当所有的任务完成后<code>group.notify(queue: concurrentQueue) {}</code>才会监听到信号，我们便可以在这里处理回到主线程后的UI任务</p>
<p>另外<code>DispatchGroup</code>还提供了wait系列的方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(timeout: DispatchTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(wallTimeout timeout: DispatchWallTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br></pre></td></tr></table></figure>

<p><code>group.notify(queue: concurrentQueue) {}</code>是监听到所有的任务结束后会在闭包里面处理结束响应的代码，他并不会阻塞线程去等待，但是’wait’系列会阻塞当前线程知道所有任务结束，我们把之前的<code>group.notify(queue: concurrentQueue) {}</code>替换如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">group.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"等待结束"</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))回到主线程\(Thread.current)"</span>)</span><br><span class="line">    <span class="keyword">self</span>.view .addSubview(<span class="type">UIView</span>.<span class="keyword">init</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">04</span>:<span class="number">14</span>:<span class="number">54</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000008a59c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">04</span>:<span class="number">14</span>:<span class="number">54</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000008a5c80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">04</span>:<span class="number">14</span>:<span class="number">54</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000008828c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">04</span>:<span class="number">15</span>:<span class="number">04</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000008a59c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">04</span>:<span class="number">15</span>:<span class="number">04</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000008a5c80</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">04</span>:<span class="number">15</span>:<span class="number">04</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000008828c0</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line">等待结束</span><br><span class="line"><span class="number">04</span>:<span class="number">15</span>:<span class="number">04</span>回到主线程&lt;<span class="type">NSThread</span>: <span class="number">0x6000008ebd80</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>因为Swift也是最近才开始自学，所以后续会补足这块其他几个方法的具体使用。</p>
<h4 id="DispatchSemaphore"><a href="#DispatchSemaphore" class="headerlink" title="DispatchSemaphore"></a>DispatchSemaphore</h4><p>之前在线程锁部分提过信号量这个，不过是Object-C的用法，既然Swift必将代替它，那么说下Swtift里的用法。</p>
<p>先说下信号量，它是一种控制访问资源的数量的标识，回一下用法，设定一个可以允许几个线程访问的信号量，在多线程访问处理的时候，先执行等待降低信号量的操作，结束在执行提高信号量的操作，一般来说他们都是成对出现的，它实现线程加锁的方式就是当我任务执行时会把信号量可访问的线程数量置位0，那样其他线程访问时都会进入等待阶段，等待当前任务完成，其他线程收到信号量增加后，便可同理执行。看下写法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        初始化一个信号量，并制定当前能访问的线程数量为1</span></span><br><span class="line"><span class="keyword">let</span> semaphore = <span class="type">DispatchSemaphore</span>.<span class="keyword">init</span>(value: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> concurrentQueue = <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">"ConcurrentQueue"</span>, qos: <span class="type">DispatchQoS</span>.<span class="keyword">default</span>, attributes: <span class="type">DispatchQueue</span>.<span class="type">Attributes</span>.concurrent, autoreleaseFrequency:.workItem, target: <span class="literal">nil</span>)</span><br><span class="line">    concurrentQueue.async &#123;</span><br><span class="line">        semaphore.wait()</span><br><span class="line">        <span class="keyword">self</span>.coreAction()</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">    concurrentQueue.async &#123;</span><br><span class="line">        semaphore.wait()</span><br><span class="line">        <span class="keyword">self</span>.coreAction()</span><br><span class="line">        semaphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">    concurrentQueue.async &#123;</span><br><span class="line">        semaphore.wait()</span><br><span class="line">        <span class="keyword">self</span>.coreAction()</span><br><span class="line">        semaphore.signal()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coreAction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> myFormatter = <span class="type">DateFormatter</span>.<span class="keyword">init</span>()</span><br><span class="line">    myFormatter.dateFormat = <span class="string">"hh:mm:ss"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))开始\(Thread.current)"</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(forTimeInterval: <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(myFormatter.string(from: Date.init()))结束\(Thread.current)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">05</span>:<span class="number">02</span>:<span class="number">19</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000013aa080</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">02</span>:<span class="number">29</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000013aa080</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">02</span>:<span class="number">29</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x60000138ec80</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">02</span>:<span class="number">39</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x60000138ec80</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">02</span>:<span class="number">39</span>开始&lt;<span class="type">NSThread</span>: <span class="number">0x6000013acc40</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">05</span>:<span class="number">02</span>:<span class="number">49</span>结束&lt;<span class="type">NSThread</span>: <span class="number">0x6000013acc40</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现同一时间只有一个线程在操作<code>coreAction</code>，这样就保证了线程安全。而信号量初始化的时候，如果将线程数量改成2，或者3，或者更多，那就表示同一段利用信号量处理的代码同时可以允许最多几个线程访问，当访问数量超过初始化的数量时，会让后访问的线程进入等待。当然具体开发过程中用的信号量的功能可能不止这些，仅列举了基本的理解和使用，具体用法还是需要具体问题具体分析的。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-08-08</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2019/08/08/这是一篇多线程/,Patrick,这是一篇多线程,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/08/21/CoreAnimation开篇/" title="动画开篇">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/08/02/这是一遍随感/" title="这是一遍随感">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>