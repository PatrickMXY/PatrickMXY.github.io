<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Patrick yangmx_patrick@foxmail.com"><title>这是一篇线程锁的理解 · Patrick</title><meta name="description" content="线程锁的由来，开发过程中遇到多个线程去修改同一内存下保存的数据的时候会导致数据紊乱，可以通过一个典型的售票的例子来帮助理解，当票数固定，同时有多个售票窗口售票时，为了做到数据精准，就必须保证同一时间只有一个窗口来售票，其他售票的窗口需要等待当前窗口售票结束才可以继续售票，这里售票窗口就可以裂解为线程"><meta name="keywords" content="Object-C,Swift,Flutter"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Patrick</a></h3><div class="description"><p>记录生活，记录bug</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">时间戳</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>这是一篇线程锁的理解</a></h3></div><div class="post-content"><p>线程锁的由来，开发过程中遇到多个线程去修改同一内存下保存的数据的时候会导致数据紊乱，可以通过一个典型的售票的例子来帮助理解，当票数固定，同时有多个售票窗口售票时，为了做到数据精准，就必须保证同一时间只有一个窗口来售票，其他售票的窗口需要等待当前窗口售票结束才可以继续售票，这里售票窗口就可以裂解为线程，售票就可以理解为需要保证线程安全的代码，这样多线程同时访问修改同一处加了线程锁的数据就可以保证数据安全了。</p>
<h3 id="线程锁的类型"><a href="#线程锁的类型" class="headerlink" title=".线程锁的类型"></a>.线程锁的类型</h3><p>线程锁的类型包括自旋锁和互斥锁。</p>
<h4 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1.自旋锁"></a>1.自旋锁</h4><p>自旋锁原理：当访问数据被其他线程加锁，则会以一种死循环的方式死等访问数据解锁，一旦解锁，等待线程便会理解执行，它是一种性能最高的线程锁，但是因为优先级翻转的bug，在iOS10 之后被os_unfair_lock替代。</p>
<p>优先级翻转：具体来说，如果一个低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock</p>
<p>用法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;os/lock.h&gt;</span>//需要导入头文件</span></span><br><span class="line"><span class="comment">// 初始化 OS_SPINLOCK_INIT默认值为 0,在 locked 状态时就会大于 0，unlocked状态下为 0</span></span><br><span class="line">OSSpinLock spinLock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">OSSpinLockLock(&amp;spinLock);</span><br><span class="line"><span class="comment">//你需要保护的操作</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">OSSpinLockUnlock(&amp;spinLock);</span><br></pre></td></tr></table></figure>

<h4 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2.互斥锁"></a>2.互斥锁</h4><p>互斥锁原理：当前线程访问的共享资源被其他线程加锁时，当前线程会进入休眠状态等待解锁，一旦访问的资源解锁，等待资源的线程就会被唤醒，它不同于自旋锁会忙等耗费大量的资源。</p>
<p>互斥锁不会同时被两个不同的线程同时得到。也就是如果是当前线程加的锁，别的线程是没有办法获取这个锁，也就没有办法对他进行解锁。光说不练假把式，我们用几种线程锁来了解它的运行机制会更明朗。</p>
<p>我们先了解下底层c的线程锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex <span class="comment">//互斥锁</span></span><br><span class="line"><span class="comment">//互斥锁的两种基本类型</span></span><br><span class="line">PTHREAD_MUTEX_NORMAL <span class="comment">//普通锁</span></span><br><span class="line">PTHREAD_MUTEX_RECURSIVE <span class="comment">//递归锁，用于递归调用的时候避免产生死锁情况。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> <span class="comment">//条件锁 就是给互斥锁加了一层条件限制，使用时先初始化一个互斥锁在初始化一个条件数据结构</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_rwlock_t</span> <span class="comment">//引申自互斥锁，就是当当前线程被读写任一模式占用时，其他线程的读写操作都会被阻塞，等待当前线程完成才会继续</span></span><br></pre></td></tr></table></figure>

<h5 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h5><p>这是苹果iOS10之后推出的新的取代<code>OSSpinLock</code>的锁。虽然是替代<code>OSSpinLock</code>的，但<code>os_unfair_lock</code>并不是自旋锁，根据苹果的官方文档可以看到其实它是一个互斥锁。从底层来看，等待<code>os_unfair_lock</code>锁的线程会处于休眠状态，也不是忙等状态。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;os/lock.h&gt;</span>//需要导入头文件</span></span><br><span class="line"><span class="comment">//    静态初始化</span></span><br><span class="line">    os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;</span><br><span class="line"><span class="comment">//    加锁</span></span><br><span class="line">    os_unfair_lock_lock(&amp;lock);</span><br><span class="line"><span class="comment">//    加锁成功会返回YES</span></span><br><span class="line">    <span class="keyword">if</span> (os_unfair_lock_trylock(&amp;lock)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    解锁</span></span><br><span class="line">    os_unfair_lock_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>因为Object-C 中用到的线程锁也基本是有苹果对C做了一层封装，方便了我们的使用，下面我们来正式认识下Object-C 中的线程锁</p>
<h5 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h5><p>一个写法最简洁的互斥锁，你不需要去手动管理加锁解锁的操作，底层会帮你把这些事情全部做了，看下例子</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(object) &#123;</span><br><span class="line">    <span class="comment">//加锁的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个object 可以是任意有生命周期的对象，一般会传入self，这样只要self未被释放，每次访问这段加了线程锁的的时候都可以保证线程安全。当然了，既然是互斥锁，当当前锁内操作正在执行的时候其他线程访问是会进入线程等待的。虽然它作为写法最简单的线程锁，但是在牺牲了性能的前提下的，因为我们也不知道底层私下里偷偷做了些什么，好奇的话可以看下<a href="[http://mrpeak.cn/blog/synchronized/](http://mrpeak.cn/blog/synchronized/)">@synchronized的正确使用</a>。</p>
<h5 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h5><p>这应该是系统提供给我们的最基本的锁对象了，他是底层对’pthread_mutex_t’，在此之前对线程锁了解不多的时候多用这种方式加锁，暂且抛开性能不谈，看一下它的基本用法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc]init];</span><br><span class="line">    [lock lock];</span><br><span class="line"><span class="comment">//    需要加锁的代码块</span></span><br><span class="line">    [lock unlock];</span><br></pre></td></tr></table></figure>

<p>假设现在在两个子线程中同时使用该锁加锁，那么后执行的加锁操作会等另一个线程解锁才会继续执行，所以’lock’ 会阻塞当前线程，这么看它是不是就满足了标准的互斥锁定义？</p>
<p>不过系统提供了一个方法’tryLock’,字面理解尝试加锁，它不会阻塞当前线程，如果要加锁的对象已经上锁，那么他会返回NO，不会让当前线程休眠进入等待的状态。为了便于理解，我们用一段代码来看看。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc]init];</span><br><span class="line"><span class="comment">//    在全局队列里异步执行两个耗时操作，由此查看结果</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程：%@ 模拟耗时操作"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"解锁"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2：%@ 模拟耗时操作"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"解锁"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">41.252352</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58435</span>:<span class="number">1844360</span>] 线程<span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">46.255199</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58435</span>:<span class="number">1844360</span>] 解锁</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">46.255233</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58435</span>:<span class="number">1844359</span>] 线程<span class="number">2</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">53</span>:<span class="number">51.258206</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58435</span>:<span class="number">1844359</span>] 解锁</span><br></pre></td></tr></table></figure>

<p>log的时间差差了5秒左右，线程2并没有像我们认识的异步执行操作那样几乎同时执行NSLog操作，而是等待线程锁解锁才会继续，至于阻塞它的，就是这个线程锁，因为线程2中执行加锁操作前它在线程1中已经加锁了，所以它必须等该线程锁解锁才会继续，它会让当前的线程进入休眠等待。这么看我们是不是基本了解了互斥锁的运行机制了</p>
<p>我们在试试’tryLock’</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc]init];</span><br><span class="line"><span class="comment">//    在全局队列里异步执行两个耗时操作，由此查看结果</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"解锁"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> ([lock tryLock]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            [lock unlock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"解锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2执行中"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">10.258854</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58522</span>:<span class="number">1848584</span>] 线程<span class="number">2</span>执行中</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">10.258853</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58522</span>:<span class="number">1848585</span>] 线程<span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">15.262588</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58522</span>:<span class="number">1848585</span>] 解锁</span><br></pre></td></tr></table></figure>

<p>是不是发现线程2突然通畅了？说明tryLock这个操作不会阻塞当前线程了，线程2礼貌的问询下当前锁可不可以加锁，可以，好，我执行，不可以？那我也不管你，我该干嘛干嘛,你别想让我等你解锁。</p>
<p>系统还提供了一个方法’lockBeforeDate:’的方法,意思是在某一时间之前尝试加锁，如果在指定时间之前都不能加锁，则会返回NO，咱用用试试</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc]init];</span><br><span class="line"><span class="comment">//    在全局队列里异步执行两个耗时操作，由此查看结果</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        [lock lock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        [lock unlock];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"解锁"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">if</span> ([lock lockBeforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">10</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">            [lock unlock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"解锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2执行中"</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">32</span>:<span class="number">53.628568</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58636</span>:<span class="number">1871827</span>] 线程<span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">32</span>:<span class="number">58.632379</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58636</span>:<span class="number">1871826</span>] 线程<span class="number">2</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">32</span>:<span class="number">58.632379</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58636</span>:<span class="number">1871827</span>] 解锁</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">33</span>:<span class="number">03.638056</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58636</span>:<span class="number">1871826</span>] 解锁</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-01</span> <span class="number">17</span>:<span class="number">33</span>:<span class="number">03.638431</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">58636</span>:<span class="number">1871826</span>] 线程<span class="number">2</span>执行中</span><br></pre></td></tr></table></figure>

<p>如果将10改成5秒内，那么会发现线程2不仅会阻塞，而且并不会执行if后的语句，简言之它会在某段时间前一直尝试加锁，可以则返回YES，不可以则返回NO，它阻塞的时间取决于当前线程锁解锁的间隔，倘若延迟时间内能解锁，则阻塞解锁等待的时间，倘若延迟是时间内不能解锁，则阻塞延迟的时间。</p>
<h5 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h5><p>条件锁，底层对’pthread_cond_t’ 的封装，看下系统提供的方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wait;   <span class="comment">// 线程等待</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)waitUntilDate:(<span class="built_in">NSDate</span> *)limit;  <span class="comment">// 设置线程等待时间，过了这个时间就会自动执行后面的代码</span></span><br><span class="line">- (<span class="keyword">void</span>)signal; <span class="comment">// 唤醒一个设置为wait等待的线程</span></span><br><span class="line">- (<span class="keyword">void</span>)broadcast;  <span class="comment">// 唤醒所有设置为wait等待的线程，这个锁一般用的较少</span></span><br></pre></td></tr></table></figure>

<p>后期底层又对它做了一层封装，所以我们通过’NSConditionLock’来了解条件锁的使用。</p>
<h5 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h5><p>‘NSConditionLock’类似’NSLock’，它遵循’NSLocking’协议，类似一个’NSLock’的衍生版本，你也可以叫它条件锁，看下系统API提供的接口</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br></pre></td></tr></table></figure>

<p>这个’condition’就是它的条件，只有当条件相等时它才可以做正确的加解锁操作，我们也可以通过每次解锁时修改条件值来实现任务间的依赖。用个例子来说明下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSConditionLock</span> *lock = [[<span class="built_in">NSConditionLock</span> alloc]initWithCondition:<span class="number">0</span>];  <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    [lock lockWhenCondition:<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程1解锁"</span>);</span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    [lock lockWhenCondition:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程2解锁"</span>);</span><br><span class="line">    [lock unlockWithCondition:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    [lock lockWhenCondition:<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程3"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"线程3解锁"</span>);</span><br><span class="line">    [lock unlockWithCondition:<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">40.815641</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324238</span>] 线程<span class="number">2</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">40.815787</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324238</span>] 线程<span class="number">2</span>解锁</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">40.816149</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324240</span>] 线程<span class="number">3</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">40.816236</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324240</span>] 线程<span class="number">3</span>解锁</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">40.816332</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324239</span>] 线程<span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">52</span>:<span class="number">40.816397</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324239</span>] 线程<span class="number">1</span>解锁</span><br></pre></td></tr></table></figure>

<p>从输出顺序可以发现原本应该最先执行的线程1 最后执行了，那是因为他条件不符啊，没有符合的条件指不定它这辈子都甭执行了，得亏在经历了线程2 和线程3 的操作后将条件改为了1，才得以实现。</p>
<p>总的来说’NSConditionLock’可以很好的实现任务之间的关联，类似信号量。</p>
<h5 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h5><p>递归锁，他也是有’NSLock’引申出来的一种，正常我们对线程锁加锁是，倘若当前线程锁已加锁，则会让当前线程进入休眠等待，但是递归锁不同，他可以重复加锁和解锁，只有当线程锁的加锁次数和解锁次数相等时才会成功解锁。它最主要的作用就是用于递归操作中的加锁。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRecursiveLock</span> *lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];  <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> (^RecursiveBlock)(<span class="keyword">int</span>);</span><br><span class="line">        RecursiveBlock = ^(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"value:%d"</span>, value);</span><br><span class="line">                RecursiveBlock(value - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        RecursiveBlock(<span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">40.816397</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324239</span>] value:<span class="number">2</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-05</span> <span class="number">11</span>:<span class="number">55</span>:<span class="number">40.816397</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">63936</span>:<span class="number">2324239</span>] value:<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这里如果使用’NSLock’ 它的特点是什么？会让线程进入等待，那下一个递归操作永远都不会执行，导致当前线程死锁。用递归锁就很好的解决了这个问题。</p>
<h5 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h5><p>信号量，如果经常使用多线程的可能会对它比较熟悉，它的作用就是保证线程同步，将异步执行的任务转换为有序的同步任务，并且能为当前线程加锁，保证线程安全。</p>
<p>简单举个例子来简单了解下它的运行机制</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//    在全局队列里异步执行多个操作，由此查看结果</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1"</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程1解锁"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2"</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程2解锁"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"线程3"</span>);</span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">57.978500</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">76266</span>:<span class="number">3136255</span>] 线程<span class="number">3</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">57.979031</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">76266</span>:<span class="number">3136256</span>] 线程<span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">57.979246</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">76266</span>:<span class="number">3136256</span>] 线程<span class="number">1</span>解锁</span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">57.979430</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">76266</span>:<span class="number">3136254</span>] 线程<span class="number">2</span></span><br><span class="line"><span class="number">2019</span><span class="number">-08</span><span class="number">-07</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">57.979614</span>+<span class="number">0800</span> <span class="built_in">NSTimer</span>+Runloop[<span class="number">76266</span>:<span class="number">3136254</span>] 线程<span class="number">2</span>解锁</span><br></pre></td></tr></table></figure>

<p>原本不加所得执行顺序虽然是异步执行的但是加了延迟的时间，应该是线程1、2、3顺序执行，但是log信息并非如我们所愿，那便是因为<code>dispatch_semaphore</code>偷偷的发挥作用。<code>dispatch_semaphore_create(0)</code> 创建一个信号为0的信号量，信号量它本身的原因导致信号为0的时候会让线程阻塞，进入等待，直到你需要进入这段阻塞的代码的时候调用<code>dispatch_semaphore_signal(semaphore)</code>就会让信号量加1，然后其他等待的线程收到信号就会停止等待，然后我们的书写方式里有个问题，就是线程 1 、2是异步执行的，<code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER)</code>他会让当前信号量减一，所以线程1和2 并不能异步执行，谁先抢占到谁先执行，按道理应该是谁先抢占到资源谁先执行,但是测试多次发现好像线程1比较牛逼，十次有九次是它走在最前头。可能虽然是异步执行，但是线程1写在前头的原因吧（纯属瞎猜,如有问题敬请告知）。</p>
<p>后续应该会单独写一篇GCD多线程的微博，会详细介绍信号量配合多线程的使用，本篇幅有限不多赘述。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title=".总结"></a>.总结</h3><p>虽然锁类众多，但是考虑到性能还是要分个优劣的。借用查阅资料的一张图可以直观的看到他们的性能排行</p>
<p><img src="/image/lock.png" alt></p>
<p>总的来说他的性能损耗程度细微到我们察觉不了的，但是作为大型的项目可能还是会考虑到这些问题，而我作为非大型项目的developer，用的可能还是@synchronized</p>
<p>谁叫他可读性高呢。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-07-24</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2019/07/24/开发中用到的线程锁/,Patrick,这是一篇线程锁的理解,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/07/30/从NSTimer的运行机制来了解RunLoop/" title="这是一篇RunLoop的理解">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/07/24/GitHub托管代码/" title="这是一篇GitHub的使用理解">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>